001 ////////////////////////////////////////////////////////////////////////////////
002 //
003 // FastjetJetProducer
004 // ------------------
005 //
006 //            04/21/2009 Philipp Schieferdecker <philipp.schieferdecker@cern.ch>
007 ////////////////////////////////////////////////////////////////////////////////
008 
009 #include "RecoJets/JetProducers/plugins/FastjetJetProducer.h"
010 
011 #include "RecoJets/JetProducers/interface/JetSpecific.h"
012 
013 #include "FWCore/Framework/interface/Event.h"
014 #include "FWCore/Framework/interface/EventSetup.h"
015 #include "FWCore/Framework/interface/ESHandle.h"
016 #include "FWCore/MessageLogger/interface/MessageLogger.h"
017 #include "FWCore/Framework/interface/MakerMacros.h"
018 
019 #include "DataFormats/Common/interface/Handle.h"
020 #include "DataFormats/VertexReco/interface/Vertex.h"
021 #include "DataFormats/VertexReco/interface/VertexFwd.h"
022 #include "DataFormats/JetReco/interface/CaloJetCollection.h"
023 #include "DataFormats/JetReco/interface/GenJetCollection.h"
024 #include "DataFormats/JetReco/interface/PFJetCollection.h"
025 #include "DataFormats/JetReco/interface/BasicJetCollection.h"
026 #include "DataFormats/Candidate/interface/CandidateFwd.h"
027 #include "DataFormats/RecoCandidate/interface/RecoChargedCandidate.h"
028 #include "DataFormats/Candidate/interface/LeafCandidate.h"
029 
030 
031 #include "Geometry/CaloGeometry/interface/CaloGeometry.h"
032 #include "Geometry/Records/interface/CaloGeometryRecord.h"
033 
034 #include "fastjet/SISConePlugin.hh"
035 #include "fastjet/CMSIterativeConePlugin.hh"
036 #include "fastjet/ATLASConePlugin.hh"
037 #include "fastjet/CDFMidPointPlugin.hh"
038 #include "fastjet/tools/Filter.hh"
039 #include "fastjet/tools/Pruner.hh"
040 #include "fastjet/tools/MassDropTagger.hh"
041 
042 #include <iostream>
043 #include <memory>
044 #include <algorithm>
045 #include <limits>
046 #include <cmath>
047 //#include <fstream>
048 
049 using namespace std;
050 
051 
052 
053 ////////////////////////////////////////////////////////////////////////////////
054 // construction / destruction
055 ////////////////////////////////////////////////////////////////////////////////
056 
057 //______________________________________________________________________________
058 FastjetJetProducer::FastjetJetProducer(const edm::ParameterSet& iConfig)
  059   : VirtualJetProducer( iConfig ),
	  060     useMassDropTagger_(false),
  061     useFiltering_(false),
  062     useTrimming_(false),
  063     usePruning_(false),
  064     muCut_(-1.0),
  065     yCut_(-1.0),
  066     rFilt_(-1.0),
  067     nFilt_(-1),
  068     trimPtFracMin_(-1.0),
  069     zCut_(-1.0),
  070     RcutFactor_(-1.0)
    071 {
072 
  073   if ( iConfig.exists("UseOnlyVertexTracks") )
  074     useOnlyVertexTracks_ = iConfig.getParameter<bool>("UseOnlyVertexTracks");
075   else 
  076     useOnlyVertexTracks_ = false;
077   
  078   if ( iConfig.exists("UseOnlyOnePV") )
  079     useOnlyOnePV_        = iConfig.getParameter<bool>("UseOnlyOnePV");
080   else
  081     useOnlyOnePV_ = false;
082 
  083   if ( iConfig.exists("DzTrVtxMax") )
  084     dzTrVtxMax_          = iConfig.getParameter<double>("DzTrVtxMax");
085   else
  086     dzTrVtxMax_ = 999999.;
 087   if ( iConfig.exists("DxyTrVtxMax") )
   088     dxyTrVtxMax_          = iConfig.getParameter<double>("DxyTrVtxMax");
089   else
   090     dxyTrVtxMax_ = 999999.;
 091   if ( iConfig.exists("MinVtxNdof") )
   092     minVtxNdof_ = iConfig.getParameter<int>("MinVtxNdof");
093   else
   094     minVtxNdof_ = 5;
 095   if ( iConfig.exists("MaxVtxZ") )
   096     maxVtxZ_ = iConfig.getParameter<double>("MaxVtxZ");
097   else
   098     maxVtxZ_ = 15;
099 
100 
  101   if ( iConfig.exists("useFiltering") ||
	     102        iConfig.exists("useTrimming") ||
	     103        iConfig.exists("usePruning") ||
	     104        iConfig.exists("useMassDropTagger") ) {
  105     useMassDropTagger_=false;
  106     useFiltering_=false;
  107     useTrimming_=false;
  108     usePruning_=false;
  109     rFilt_=-1.0;
  110     nFilt_=-1;
  111     trimPtFracMin_=-1.0;
  112     zCut_=-1.0;
  113     RcutFactor_=-1.0;
  114     muCut_=-1.0;
  115     yCut_=-1.0;
  116     useExplicitGhosts_ = true;
117 
118 
  119     if ( iConfig.exists("useMassDropTagger") ) {
  120       useMassDropTagger_ = true;
  121       muCut_ = iConfig.getParameter<double>("muCut");
  122       yCut_ = iConfig.getParameter<double>("yCut");
  123 }
124 
  125     if ( iConfig.exists("useFiltering") ) {
  126       useFiltering_ = true;
  127       rFilt_ = iConfig.getParameter<double>("rFilt");
  128       nFilt_ = iConfig.getParameter<int>("nFilt");
  129 }
130   
  131     if ( iConfig.exists("useTrimming") ) {
  132       useTrimming_ = true;
  133       rFilt_ = iConfig.getParameter<double>("rFilt");
  134       trimPtFracMin_ = iConfig.getParameter<double>("trimPtFracMin");
  135 }
136 
  137     if ( iConfig.exists("usePruning") ) {
  138       usePruning_ = true;
  139       zCut_ = iConfig.getParameter<double>("zcut");
  140       RcutFactor_ = iConfig.getParameter<double>("rcut_factor");
  141       nFilt_ = iConfig.getParameter<int>("nFilt");
  142 }
143 
  144 }
145 
  146 }
147 
148 
149 //______________________________________________________________________________
150 FastjetJetProducer::~FastjetJetProducer()
  151 {
  152 } 
153 
154 
155 ////////////////////////////////////////////////////////////////////////////////
156 // implementation of member functions
157 ////////////////////////////////////////////////////////////////////////////////
158 
159 void FastjetJetProducer::produce( edm::Event & iEvent, const edm::EventSetup & iSetup )
  160 {
161 
  162   // for everything but track jets
  163   if (!makeTrackJet(jetTypeE)) {
164  
  165      // use the default production from one collection
  166      VirtualJetProducer::produce( iEvent, iSetup );
167 
  168 } else { // produce trackjets from tracks grouped per primary vertex
169 
  170     produceTrackJets(iEvent, iSetup);
171   
  172 }
173 
  174 }
175 
176 
177 void FastjetJetProducer::produceTrackJets( edm::Event & iEvent, const edm::EventSetup & iSetup )
  178 {
179 
  180     // read in the track candidates
  181     edm::Handle<edm::View<reco::RecoChargedRefCandidate> > inputsHandle;
 182     iEvent.getByLabel(src_, inputsHandle);
 183     // make collection with pointers so we can play around with it
   184     std::vector<edm::Ptr<reco::RecoChargedRefCandidate> > allInputs;
 185     std::vector<edm::Ptr<reco::Candidate> > origInputs;
 186     for (size_t i = 0; i < inputsHandle->size(); ++i) {
   187       allInputs.push_back(inputsHandle->ptrAt(i));
   188       origInputs.push_back(inputsHandle->ptrAt(i));
   189 }
190 
  191     // read in the PV collection
  192     edm::Handle<reco::VertexCollection> pvCollection;
 193     iEvent.getByLabel(srcPVs_, pvCollection);
 194     // define thtVtx->ndof() < minVtxNdof_ || fabs(itVtx->z()) > maxVtxZ_) continue;
200 
   201       // clear the intermediate containers
   202       inputs_.clear();
 203       fjInputs_.clear();
 204       fjJets_.clear();
205 
  206       // if only vertex-associated tracks should be used
  207       if (useOnlyVertexTracks_) {
  208         // loop over the tracks associated to the vertex
    209      trref) {
  218               found = true;
  219               // add this track candidate to the input for clustering
    220               inputs_.push_back(*itIn);
  221               // erase the track candidate from the total list of input, so we don't reuse it later
    222               allInputs.erase(itIn);
  223               // found the candidate track corresponding to the vertex track, so stop the loop
    224               break;
  225 } // end if match found
 226 } // end loop over input tracks
227           // give an info message in case no match is found (can happen if candidates ardRefCandidate> >::iterator itIn = allInputs.begin(); itIn != allInputs.end(); ++itIn) {
234           // check if the track is close enough to the vertex
235           float dz = (*itIn)->track()->dz(itVtx->position());
236           float dxy = (*itIn)->track()->dxy(itVtx->position());
237           if (fabs(dz) > dzTrVtxMax_) continue;
238           if (fabs(dxy) > dxyTrVtxMax_) continue;
239           bool closervtx = false;
240           // now loop over the good vertices a second time
241           for (reco::VertexCollection::const_iterator itVtx2 = pvCollection->begin(); itVtx2 != pvCollection->end(); ++itVtx2) {
  242             if (itVtx->isFake() || itVtx->ndof() < minVtxNdof_ || fabs(itVtx->z()) > maxVtxZ_) continue;
  243             // and check this track is closer to any other vertex (if more than 1 vertex considered)
    244             if (!useOnlyOnePV_ &&
245                 itVtx != itVtx2 &&
			246                 fabs((*itIn)->track()->dz(itVtx2->position())) < fabs(dz)) {
    247               closervtx = true;
    248               break; // 1 closer vertex makes the track already not matched, so break
    249 }
  250 }
251           // don't add this track if another vertex is found closer
252           if (closervtx) continue;
253           // add this track candidate to the input for clustering
254           inputs_.push_back(*itIn);
255           // erase the track candidate from the total list of input, so we don't reuse it later
256           allInputs.erase(itIn);
257           // take a step back in the loop since we just erased
258           --itIn;
259 }
260 }
261 
262       // convert candidates in inputs_ to fastjet::PseudoJets in fjInputs_
263       fjInputs_.reserve(inputs_.size());
264       inputTowers();
265       LogDebug("FastjetTrackJetProducer") << "Inputted towers\n";
266 
267       // run algorithm, using fjInputs_, modifying fjJets_ and allocating fjClusterSeq_
268       runAlgorithm(iEvent, iSetup)Ran algorithm\n";
270 
271       // convert our jets and add to the overall jet vector
272       for (unsigned int ijet=0;ijet<fjJets_.size();++ijet) {
273         // get the constituents from fastjet
274         std::vector<fastjet::PseudoJet> fjConstituents = sorted_by_pt(fjClusterSeq_->constituents(fjJets_[ijet]));
275         // convert them to CandidatePtr vec286         jet.setVertex(itVtx->position());
287         jets->push_back(jet);
288       }
289 
290       if (useOnlyOnePV_) break; // stop vertex loop if only one vertex asked for
291     } // end loop over vertices
292 
293     // put the jets in the collection
294     LogDebug("FastjetTrackJetProducer") << "Put " << jets->size() << " jets in the event.\n";
295     iEvent.put(jets);
296 
297 }
298 
299 
300 //______________________________________________________________________________
301 void FastjetJetProducer::runAlgorithm( edm::Event & iEvent, edm::EventSetup const& iSetup)
302 {
303   // run algorithm
304   /*
305   fjInputs_.clear();
306   double px, py , pz, E;
307   string line;
308   std::ifstream fin("dump3.txt");
309   while (getline(fin, line)){
310     if (line == "#END") break;
311     if (line.substr(0,1) == "#") {continue;}
312     istringstream istr(line);
313     istr >> px >> py >> pz >> E;
314     // create a fastjet::PseudoJet with these components and put it onto
315     // back of the input_particles vector
316     fastjet::PseudoJet j(px,py,pz,E);
317     //if ( fabs(j.rap()) < inputEtaMax )
318     fjInputs_.push_back(fastjet::PseudoJet(px,py,pz,E)); 
319   }
320   fin.close();
321   */
322 
323   if ( !doAreaFastjet_ && !doRhoFastjet_) {
324     fjClusterSeq_ = ClusterSequencePtr( new fastjet::ClusterSequence( fjInputs_, *fjJetDefinition_ ) );
325   } else if (voronoiRfact_ <= 0) {
326     fjClusterSeq_ = ClusterSequencePtr( new fastjet::ClusterSequenceArea( fjInputs_, *fjJetDefinition_ , *fjAreaDefinition_ ) );
327   } else {
328     fjClusterSeq_ = ClusterSequencePtr( new fastjet::ClusterSequenceVoronoiArea( fjInputs_, *fjJetDefinition_ , fastjet::VoronoiAreaSpec(voronoiRfact_) ) );
329   }
330 
331   if ( !useTrimming_ && !useFiltering_ && !usePruning_ ) {
332     fjJets_ = fastjet::sorted_by_pt(fjClusterSeq_->inclusive_jets(jetPtMin_));
333   }
334   else {
335     fjJets_.clear();
336     std::vector<fastjet::PseudoJet> tempJets = fastjet::sorted_by_pt(fjClusterSeq_->inclusive_jets(jetPtMin_));
337 
338     fastjet::MassDropTagger md_tagger( muCut_, yCut_ );
339     fastjet::Filter trimmer( fastjet::Filter(fastjet::JetDefinition(fastjet::kt_algorithm, rFilt_), fastjet::SelectorPtFractionMin(trimPtFracMin_)));
340     fastjet::Filter filter( fastjet::Filter(fastjet::JetDefinition(fastjet::cambridge_algorithm, rFilt_), fastjet::SelectorNHardest(nFilt_)));
341     fastjet::Pruner pruner(fastjet::cambridge_algorithm, zCut_, RcutFactor_);
342 
343     std::vector<fastjet::Transformer const *> transformers;
344 
345     if ( useMassDropTagger_ ) {
346       transformers.push_back(&md_tagger);
347     }
348     if ( useTrimming_ ) {
349       transformers.push_back(&trimmer);
350     } 
351     if ( useFiltering_ ) {
352       transformers.push_back(&filter);
353     } 
354     if ( usePruning_ ) {
355       transformers.push_back(&pruner);
356     }
357 
358 
359 
360     for ( std::vector<fastjet::PseudoJet>::const_iterator ijet = tempJets.begin(),
361             ijetEnd = tempJets.end(); ijet != ijetEnd; ++ijet ) {
362 
363       fastjet::PseudoJet transformedJet = *ijet;
364       bool passed = true;
365       for ( std::vector<fastjet::Transformer const *>::const_iterator itransf = transformers.begin(),
366               itransfEnd = transformers.end(); itransf != itransfEnd; ++itransf ) {
367         if ( transformedJet != 0 ) {
368           transformedJet = (**itransf)(transformedJet);
369         }
370         else {
37
